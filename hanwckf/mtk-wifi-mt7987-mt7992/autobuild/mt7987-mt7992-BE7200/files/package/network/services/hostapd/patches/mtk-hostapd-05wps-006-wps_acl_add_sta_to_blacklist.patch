diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index 87fc615..03d559e 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -299,6 +299,7 @@ struct hostapd_data {
 	unsigned int ap_pin_lockout_time;
 
 	struct wps_stat wps_stats;
+	u8 black_listed_sta[6];
 #endif /* CONFIG_WPS */
 
 #ifdef CONFIG_MACSEC
diff --git a/src/ap/wps_hostapd.c b/src/ap/wps_hostapd.c
index 2ead318..ec0536c 100644
--- a/src/ap/wps_hostapd.c
+++ b/src/ap/wps_hostapd.c
@@ -28,6 +28,15 @@
 #include "wps_hostapd.h"
 
 
+#if defined(CONFIG_MTK_IEEE80211BE) && defined(CONFIG_WPS)
+#include "netlink/genl/genl.h"
+#include "mtk_vendor_nl80211.h"
+#include "../drivers/nl80211_copy.h"
+#include "../drivers/driver_nl80211.h"
+#define STA_BLACKLIST_TIME 180
+#define MAX_ACL_DUMP_LEN 4096
+#endif
+
 #ifdef CONFIG_WPS_UPNP
 #include "wps/wps_upnp.h"
 static int hostapd_wps_upnp_init(struct hostapd_data *hapd,
@@ -766,6 +775,168 @@ static void hostapd_wps_reenable_ap_pin(void *eloop_data, void *user_ctx)
 }
 
 
+#if defined(CONFIG_MTK_IEEE80211BE) && defined(CONFIG_WPS)
+static void hostapd_wps_sta_blacklist_timeout(void *eloop_data, void *user_ctx)
+{
+	struct hostapd_data *hapd = eloop_data;
+	struct i802_bss *bss = hapd->drv_priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg = NULL;
+	struct nlattr *attr;
+	int ret = 0;
+
+	wpa_printf(MSG_DEBUG, "WPS: Remove Blacklisted STA: " MACSTR, MAC2STR(hapd->black_listed_sta));
+	if(drv)
+	{
+		if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+				nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, MTK_NL80211_VENDOR_ID) ||
+				nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_SET_ACL))
+			goto fail;
+
+		attr = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+		if (!attr)
+			goto fail;
+
+		if (nla_put(msg, MTK_NL80211_VENDOR_ATTR_ACL_DEL_MAC, ETH_ALEN,
+					(void *)hapd->black_listed_sta))
+			goto fail;
+		nla_nest_end(msg, attr);
+
+		ret = send_and_recv_msgs(drv, msg, NULL, NULL, NULL, NULL);
+		msg = NULL;
+		if (ret)
+			wpa_printf(MSG_ERROR, "Could not remove STA from ACL Entry %d (%s)",
+					ret, strerror(-ret));
+	}
+	wpa_printf(MSG_DEBUG, "WPS: Removed Blacklisted STA: " MACSTR, MAC2STR(hapd->black_listed_sta));
+	return;
+fail:
+	nlmsg_free(msg);
+	return;
+}
+
+
+int acl_list_dump_callback(struct nl_msg *msg, void *cb)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct nlattr *vndr_tb[MTK_NL80211_VENDOR_AP_ACL_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	char *show_str = NULL;
+	int err = 0;
+	u16 acl_result_len = 0;
+	int *cur_acl_policy = (int*)cb;
+
+	err = nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+			  genlmsg_attrlen(gnlh, 0), NULL);
+	if (err < 0)
+		return err;
+
+	if (tb[NL80211_ATTR_VENDOR_DATA]) {
+		err = nla_parse_nested(vndr_tb, MTK_NL80211_VENDOR_AP_ACL_ATTR_MAX,
+			tb[NL80211_ATTR_VENDOR_DATA], NULL);
+		if (err < 0)
+			return err;
+
+		if (vndr_tb[MTK_NL80211_VENDOR_ATTR_ACL_LIST_INFO]) {
+			acl_result_len = nla_len(vndr_tb[MTK_NL80211_VENDOR_ATTR_ACL_LIST_INFO]);
+			show_str = nla_data(vndr_tb[MTK_NL80211_VENDOR_ATTR_ACL_LIST_INFO]);
+			if (acl_result_len > MAX_ACL_DUMP_LEN) {
+				wpa_printf(MSG_DEBUG,"the scan result len is invalid !!!\n");
+				return -EINVAL;
+			} else if (*(show_str + acl_result_len - 1) != '\0') {
+				wpa_printf(MSG_DEBUG,"the result string is not ended with right terminator, handle it!!!\n");
+				*(show_str + acl_result_len - 1) = '\0';
+			}
+			if(!strncmp(show_str, "policy=",7))
+				*cur_acl_policy  =  (*(show_str+7)) - 48;
+		} else
+			wpa_printf(MSG_DEBUG,"no acl result attr");
+	} else
+		wpa_printf(MSG_DEBUG, "no any acl result from driver");
+
+	return 0;
+}
+
+static int wps_check_existing_acl_policy(struct wpa_driver_nl80211_data *drv)
+{
+	struct nl_msg *msg = NULL;
+	struct nlattr *attr;
+	int ret, cur_acl_policy = 0;
+
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+			nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, MTK_NL80211_VENDOR_ID) ||
+			nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_SET_ACL))
+		goto fail;
+
+	attr = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!attr)
+		goto fail;
+
+	nla_put_flag(msg, MTK_NL80211_VENDOR_ATTR_ACL_SHOW_ALL);
+
+	nla_nest_end(msg, attr);
+	ret = send_and_recv_msgs(drv, msg, acl_list_dump_callback, &cur_acl_policy, NULL, NULL);
+	msg = NULL;
+	if (ret)
+	{
+		wpa_printf(MSG_ERROR, "failed to find ACL policy err %d (%s)",
+				ret, strerror(-ret));
+		return ret;
+	}
+
+	return cur_acl_policy;
+
+fail:
+	nlmsg_free(msg);
+	return ret;
+}
+
+
+static int wps_add_sta_to_black_list(struct wpa_driver_nl80211_data *drv,
+		const u8 *data, size_t data_len)
+{
+	struct nl_msg *msg = NULL;
+	struct nlattr *attr;
+	int ret;
+	int cur_acl_policy = 0;
+
+	cur_acl_policy = wps_check_existing_acl_policy(drv);
+	if(cur_acl_policy == MTK_NL80211_VENDOR_ATTR_ACL_ENABLE_WHITE_LIST)
+	{
+		wpa_printf(MSG_DEBUG, "ACL policy set to whitelist");
+		return 0;
+	}
+	if (!(msg = nl80211_drv_msg(drv, 0, NL80211_CMD_VENDOR)) ||
+			nla_put_u32(msg, NL80211_ATTR_VENDOR_ID, MTK_NL80211_VENDOR_ID) ||
+			nla_put_u32(msg, NL80211_ATTR_VENDOR_SUBCMD, MTK_NL80211_VENDOR_SUBCMD_SET_ACL))
+		goto fail;
+
+	attr = nla_nest_start(msg, NL80211_ATTR_VENDOR_DATA);
+	if (!attr)
+		goto fail;
+
+	if (nla_put_u8(msg, MTK_NL80211_VENDOR_ATTR_ACL_POLICY, MTK_NL80211_VENDOR_ATTR_ACL_ENABLE_BLACK_LIST))
+		goto fail;
+
+	if (nla_put(msg, MTK_NL80211_VENDOR_ATTR_ACL_ADD_MAC, data_len,
+				(void *)data))
+		goto fail;
+	nla_nest_end(msg, attr);
+
+	ret = send_and_recv_msgs(drv, msg, NULL, NULL, NULL, NULL);
+	msg = NULL;
+	if (ret)
+		wpa_printf(MSG_ERROR, "Could not set and add STA MAC to ACL list err %d (%s)",
+				ret, strerror(-ret));
+	return ret;
+
+fail:
+	nlmsg_free(msg);
+	return ret;
+}
+#endif
+
+
 static int wps_pwd_auth_fail(struct hostapd_data *hapd, void *ctx)
 {
 	struct wps_event_pwd_auth_fail *data = ctx;
@@ -812,6 +983,23 @@ static int wps_pwd_auth_fail(struct hostapd_data *hapd, void *ctx)
 		eloop_register_timeout(hapd->ap_pin_lockout_time, 0,
 				       hostapd_wps_reenable_ap_pin, hapd,
 				       NULL);
+#if defined(CONFIG_MTK_IEEE80211BE) && defined(CONFIG_WPS)
+		struct i802_bss *bss = hapd->drv_priv;
+		struct wpa_driver_nl80211_data *drv = bss->drv;
+
+		eloop_cancel_timeout(hostapd_wps_sta_blacklist_timeout, hapd, NULL);
+		eloop_register_timeout(STA_BLACKLIST_TIME, 0,
+				hostapd_wps_sta_blacklist_timeout, hapd,
+				NULL);
+		if(drv)
+		{
+			if (!wps_add_sta_to_black_list(drv,data->peer_macaddr, ETH_ALEN))
+			{
+				wpa_printf(MSG_DEBUG, "WPS: Blacklisted STA : " MACSTR, MAC2STR(data->peer_macaddr));
+				os_memcpy(hapd->black_listed_sta, data->peer_macaddr, ETH_ALEN);
+			}
+		}
+#endif
 	}
 
 	return 0;
