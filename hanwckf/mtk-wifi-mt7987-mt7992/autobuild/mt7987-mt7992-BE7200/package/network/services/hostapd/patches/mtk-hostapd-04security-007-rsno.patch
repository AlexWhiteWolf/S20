Index: hostapd-2022-07-29-b704dc72/hostapd/config_file.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/hostapd/config_file.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/hostapd/config_file.c	2024-11-20 12:19:55.289941000 +0800
@@ -2954,6 +2954,11 @@
 		bss->wpa_key_mgmt = hostapd_config_parse_key_mgmt(line, pos);
 		if (bss->wpa_key_mgmt == -1)
 			return 1;
+	} else if (os_strcmp(buf, "rsn_override_key_mgmt") == 0) {
+		bss->rsn_override_key_mgmt =
+			hostapd_config_parse_key_mgmt(line, pos);
+		if (bss->rsn_override_key_mgmt == -1)
+			return 1;
 	} else if (os_strcmp(buf, "wpa_psk_radius") == 0) {
 		bss->wpa_psk_radius = atoi(pos);
 		if (bss->wpa_psk_radius != PSK_RADIUS_IGNORED &&
@@ -2985,6 +2990,19 @@
 				   line, pos);
 			return 1;
 		}
+	} else if (os_strcmp(buf, "rsn_override_pairwise") == 0) {
+		bss->rsn_override_pairwise =
+			hostapd_config_parse_cipher(line, pos);
+		if (bss->rsn_override_pairwise == -1 ||
+		    bss->rsn_override_pairwise == 0)
+			return 1;
+		if (bss->rsn_override_pairwise &
+		    (WPA_CIPHER_NONE | WPA_CIPHER_WEP40 | WPA_CIPHER_WEP104)) {
+			wpa_printf(MSG_ERROR,
+				   "Line %d: unsupported pairwise cipher suite '%s'",
+				   line, pos);
+			return 1;
+		}
 	} else if (os_strcmp(buf, "group_cipher") == 0) {
 		bss->group_cipher = hostapd_config_parse_cipher(line, pos);
 		if (bss->group_cipher == -1 || bss->group_cipher == 0)
@@ -3461,6 +3479,8 @@
 		conf->conf_changed = 1;
 	} else if (os_strcmp(buf, "ieee80211w") == 0) {
 		bss->ieee80211w = atoi(pos);
+	} else if (os_strcmp(buf, "rsn_override_mfp") == 0) {
+		bss->rsn_override_mfp = atoi(pos);
 	} else if (os_strcmp(buf, "group_mgmt_cipher") == 0) {
 		if (os_strcmp(pos, "AES-128-CMAC") == 0) {
 			bss->group_mgmt_cipher = WPA_CIPHER_AES_128_CMAC;
Index: hostapd-2022-07-29-b704dc72/hostapd/ctrl_iface.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/hostapd/ctrl_iface.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/hostapd/ctrl_iface.c	2024-11-20 12:19:55.305874000 +0800
@@ -1000,7 +1000,7 @@
 #endif /* CONFIG_FILS */
 
 #ifdef CONFIG_OWE
-	if (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) {
+	if ((hapd->conf->wpa_key_mgmt | hapd->conf->rsn_override_key_mgmt) & WPA_KEY_MGMT_OWE) {
 		ret = os_snprintf(pos, end - pos, "OWE ");
 		if (os_snprintf_error(end - pos, ret))
 			return pos - buf;
Index: hostapd-2022-07-29-b704dc72/src/ap/ap_config.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/ap_config.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/ap_config.c	2024-11-20 12:19:55.335872000 +0800
@@ -482,10 +482,11 @@
 	struct sae_password_entry *pw;
 
 	if ((conf->sae_pwe == 0 && !hostapd_sae_pw_id_in_use(conf) &&
-	     !wpa_key_mgmt_sae_ext_key(conf->wpa_key_mgmt) &&
+	     !wpa_key_mgmt_sae_ext_key(conf->wpa_key_mgmt |
+				       conf->rsn_override_key_mgmt) &&
 	     !hostapd_sae_pk_in_use(conf)) ||
 	    conf->sae_pwe == 3 ||
-	    !wpa_key_mgmt_sae(conf->wpa_key_mgmt))
+	    !wpa_key_mgmt_sae(conf->wpa_key_mgmt | conf->rsn_override_key_mgmt))
 		return 0; /* PT not needed */
 
 	sae_deinit_pt(ssid->pt);
Index: hostapd-2022-07-29-b704dc72/src/ap/ap_config.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/ap_config.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/ap_config.h	2024-11-20 12:19:55.347836000 +0800
@@ -361,7 +361,9 @@
 	int wpa; /* bitfield of WPA_PROTO_WPA, WPA_PROTO_RSN */
 	int extended_key_id;
 	int wpa_key_mgmt;
+	int rsn_override_key_mgmt;
 	enum mfp_options ieee80211w;
+	enum mfp_options rsn_override_mfp;
 	int group_mgmt_cipher;
 	int beacon_prot;
 	/* dot11AssociationSAQueryMaximumTimeout (in TUs) */
@@ -390,6 +392,7 @@
 	u32 wpa_pairwise_update_count;
 	int wpa_disable_eapol_key_retries;
 	int rsn_pairwise;
+	int rsn_override_pairwise;
 	int rsn_preauth;
 	char *rsn_preauth_interfaces;
 
Index: hostapd-2022-07-29-b704dc72/src/ap/beacon.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/beacon.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/beacon.c	2024-11-20 12:19:55.355948000 +0800
@@ -398,6 +398,56 @@
 }
 
 
+static u8 * hostapd_get_rsne_override(struct hostapd_data *hapd, u8 *pos,
+				      size_t len)
+{
+	const u8 *ie;
+
+	ie = hostapd_vendor_wpa_ie(hapd, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+	if (!ie || 2U + ie[1] > len)
+		return pos;
+
+	os_memcpy(pos, ie, 2 + ie[1]);
+	return pos + 2 + ie[1];
+}
+
+
+static u8 * hostapd_get_rsnxe_override(struct hostapd_data *hapd, u8 *pos,
+				       size_t len)
+{
+	const u8 *ie;
+
+	ie = hostapd_vendor_wpa_ie(hapd, RSNXE_OVERRIDE_IE_VENDOR_TYPE);
+	if (!ie || 2U + ie[1] > len)
+		return pos;
+
+	os_memcpy(pos, ie, 2 + ie[1]);
+	return pos + 2 + ie[1];
+}
+
+
+static size_t hostapd_get_rsne_override_len(struct hostapd_data *hapd)
+{
+	const u8 *ie;
+
+	ie = hostapd_vendor_wpa_ie(hapd, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+	if (!ie)
+		return 0;
+	return 2 + ie[1];
+}
+
+
+static size_t hostapd_get_rsnxe_override_len(struct hostapd_data *hapd)
+{
+	const u8 *ie;
+
+	ie = hostapd_vendor_wpa_ie(hapd, RSNXE_OVERRIDE_IE_VENDOR_TYPE);
+	if (!ie)
+		return 0;
+	return 2 + ie[1];
+}
+
+
 static u8 * hostapd_eid_csa(struct hostapd_data *hapd, u8 *eid)
 {
 #ifdef CONFIG_TESTING_OPTIONS
@@ -521,6 +571,8 @@
 	buflen += hostapd_mbo_ie_len(hapd);
 	buflen += hostapd_eid_owe_trans_len(hapd);
 	buflen += hostapd_eid_dpp_cc_len(hapd);
+	buflen += hostapd_get_rsne_override_len(hapd);
+	buflen += hostapd_get_rsnxe_override_len(hapd);
 
 	resp = os_zalloc(buflen);
 	if (resp == NULL)
@@ -695,6 +747,9 @@
 	pos = hostapd_eid_owe_trans(hapd, pos, (u8 *) resp + buflen - pos);
 	pos = hostapd_eid_dpp_cc(hapd, pos, (u8 *) resp + buflen - pos);
 
+	pos = hostapd_get_rsne_override(hapd, pos, (u8 *) resp + buflen - pos);
+	pos = hostapd_get_rsnxe_override(hapd, pos, (u8 *) resp + buflen - pos);
+
 	if (hapd->conf->vendor_elements) {
 		os_memcpy(pos, wpabuf_head(hapd->conf->vendor_elements),
 			  wpabuf_len(hapd->conf->vendor_elements));
@@ -1582,6 +1637,8 @@
 	tail_len += hostapd_mbo_ie_len(hapd);
 	tail_len += hostapd_eid_owe_trans_len(hapd);
 	tail_len += hostapd_eid_dpp_cc_len(hapd);
+	tail_len += hostapd_get_rsne_override_len(hapd);
+	tail_len += hostapd_get_rsnxe_override_len(hapd);
 
 	tailpos = tail = os_malloc(tail_len);
 	if (head == NULL || tail == NULL) {
@@ -1778,7 +1835,10 @@
 	tailpos = hostapd_eid_owe_trans(hapd, tailpos,
 					tail + tail_len - tailpos);
 	tailpos = hostapd_eid_dpp_cc(hapd, tailpos, tail + tail_len - tailpos);
-
+	tailpos = hostapd_get_rsne_override(hapd, tailpos,
+					    tail + tail_len - tailpos);
+	tailpos = hostapd_get_rsnxe_override(hapd, tailpos,
+					     tail + tail_len - tailpos);
 	if (hapd->conf->vendor_elements) {
 		os_memcpy(tailpos, wpabuf_head(hapd->conf->vendor_elements),
 			  wpabuf_len(hapd->conf->vendor_elements));
@@ -1813,7 +1873,8 @@
 	else if (hapd->conf->wpa & WPA_PROTO_WPA)
 		params->pairwise_ciphers = hapd->conf->wpa_pairwise;
 	params->group_cipher = hapd->conf->wpa_group;
-	params->key_mgmt_suites = hapd->conf->wpa_key_mgmt;
+	params->key_mgmt_suites = hapd->conf->wpa_key_mgmt |
+		hapd->conf->rsn_override_key_mgmt;
 	params->auth_algs = hapd->conf->auth_algs;
 	params->wpa_version = hapd->conf->wpa;
 	params->privacy = hapd->conf->wpa;
Index: hostapd-2022-07-29-b704dc72/src/ap/drv_callbacks.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/drv_callbacks.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/drv_callbacks.c	2024-11-20 12:19:55.364855000 +0800
@@ -376,7 +376,8 @@
 				   "Failed to initialize WPA state machine");
 			return -1;
 		}
-		
+		wpa_auth_set_rsn_override(sta->wpa_sm,
+					  elems.rsne_override != NULL);
 #ifdef CONFIG_MTK_IEEE80211BE
 		ml_new_assoc_sta(sta->wpa_sm, elems.ml, elems.ml_len);
 #endif
Index: hostapd-2022-07-29-b704dc72/src/ap/ieee802_11.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/ieee802_11.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/ieee802_11.c	2024-11-20 12:19:55.393891000 +0800
@@ -2059,6 +2059,9 @@
 	if (resp != WLAN_STATUS_SUCCESS)
 		goto fail;
 
+	wpa_auth_set_rsn_override(sta->wpa_sm,
+				  elems.rsne_override != NULL);
+
 	if (!elems.fils_nonce) {
 		wpa_printf(MSG_DEBUG, "FILS: No FILS Nonce field");
 		resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
@@ -3795,7 +3798,8 @@
 	       auth_alg == WLAN_AUTH_FT) ||
 #endif /* CONFIG_IEEE80211R_AP */
 #ifdef CONFIG_SAE
-	      (hapd->conf->wpa && wpa_key_mgmt_sae(hapd->conf->wpa_key_mgmt) &&
+	      (hapd->conf->wpa && wpa_key_mgmt_sae(hapd->conf->wpa_key_mgmt |
+				hapd->conf->rsn_override_key_mgmt) &&
 	       auth_alg == WLAN_AUTH_SAE) ||
 #endif /* CONFIG_SAE */
 #ifdef CONFIG_FILS
@@ -4807,7 +4811,8 @@
 				   "state machine");
 			return WLAN_STATUS_UNSPECIFIED_FAILURE;
 		}
-		
+		wpa_auth_set_rsn_override(sta->wpa_sm,
+						  elems.rsne_override != NULL);
 #ifdef CONFIG_MTK_IEEE80211BE
 		ml_new_assoc_sta(sta->wpa_sm, elems.ml, elems.ml_len); /*for logan owe flow*/
 #endif
@@ -4884,7 +4889,7 @@
 		}
 #endif /* CONFIG_SAE */
 #ifdef CONFIG_OWE
-		if ((hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) &&
+		if (((hapd->conf->wpa_key_mgmt | hapd->conf->rsn_override_key_mgmt) & WPA_KEY_MGMT_OWE) &&
 		    wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_OWE &&
 		    elems.owe_dh) {
 			resp = owe_process_assoc_req(hapd, sta, elems.owe_dh,
@@ -5232,7 +5237,7 @@
 		buflen += 150;
 #endif /* CONFIG_FILS */
 #ifdef CONFIG_OWE
-	if (sta && (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE))
+	if (sta && ((hapd->conf->wpa_key_mgmt | hapd->conf->rsn_override_key_mgmt) & WPA_KEY_MGMT_OWE))
 		buflen += 150;
 #endif /* CONFIG_OWE */
 #ifdef CONFIG_DPP2
@@ -5318,7 +5323,7 @@
 
 #ifdef CONFIG_OWE
 	if (sta && status_code == WLAN_STATUS_SUCCESS &&
-	    (hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE))
+	    ((hapd->conf->wpa_key_mgmt | hapd->conf->rsn_override_key_mgmt) & WPA_KEY_MGMT_OWE))
 		p = wpa_auth_write_assoc_resp_owe(sta->wpa_sm, p,
 						  buf + buflen - p,
 						  ies, ies_len);
@@ -5404,7 +5409,7 @@
 #endif /* CONFIG_IEEE80211BE */
 
 #ifdef CONFIG_OWE
-	if ((hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) &&
+	if (((hapd->conf->wpa_key_mgmt | hapd->conf->rsn_override_key_mgmt) & WPA_KEY_MGMT_OWE) &&
 	    sta && sta->owe_ecdh && status_code == WLAN_STATUS_SUCCESS &&
 	    wpa_auth_sta_key_mgmt(sta->wpa_sm) == WPA_KEY_MGMT_OWE &&
 	    !wpa_auth_sta_get_pmksa(sta->wpa_sm)) {
Index: hostapd-2022-07-29-b704dc72/src/ap/wpa_auth.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/wpa_auth.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/wpa_auth.c	2024-11-20 12:19:55.407906000 +0800
@@ -771,6 +771,8 @@
 
 
 	os_free(wpa_auth->wpa_ie);
+	os_free(wpa_auth->rsne_override);
+	os_free(wpa_auth->rsnxe_override);
 
 	group = wpa_auth->group;
 	while (group) {
@@ -3639,7 +3641,7 @@
 	struct wpa_group *gsm = sm->group;
 	u8 *wpa_ie;
 	int secure, gtkidx, encr = 0;
-	u8 *wpa_ie_buf = NULL, *wpa_ie_buf2 = NULL;
+	u8 *wpa_ie_buf = NULL, *wpa_ie_buf2 = NULL, *wpa_ie_buf3 = NULL;
 	u8 hdr[2];
 	struct wpa_auth_config *conf = &sm->wpa_auth->conf;
 
@@ -3675,6 +3677,75 @@
 			wpa_ie = wpa_ie + wpa_ie[1] + 2;
 		wpa_ie_len = wpa_ie[1] + 2;
 	}
+	if (sm->rsn_override &&
+	    get_vendor_ie(wpa_ie, wpa_ie_len, RSNE_OVERRIDE_IE_VENDOR_TYPE)) {
+		const u8 *mde, *fte, *tie, *tie2 = NULL;
+		const u8 *override_rsne = NULL, *override_rsnxe = NULL;
+		const struct element *elem;
+
+		wpa_printf(MSG_DEBUG,
+			   "RSN: Use RSNE/RSNXE override element contents");
+		mde = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_MOBILITY_DOMAIN);
+		fte = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_FAST_BSS_TRANSITION);
+		tie = get_ie(wpa_ie, wpa_ie_len, WLAN_EID_TIMEOUT_INTERVAL);
+		if (tie) {
+			const u8 *next = tie + 2 + tie[1];
+
+			tie2 = get_ie(next, wpa_ie + wpa_ie_len - next,
+				      WLAN_EID_TIMEOUT_INTERVAL);
+		}
+		for_each_element_id(elem, WLAN_EID_VENDOR_SPECIFIC,
+				    wpa_ie, wpa_ie_len) {
+			if (elem->datalen >= 4) {
+				if (WPA_GET_BE32(elem->data) ==
+				    RSNE_OVERRIDE_IE_VENDOR_TYPE)
+					override_rsne = &elem->id;
+				if (WPA_GET_BE32(elem->data) ==
+				    RSNXE_OVERRIDE_IE_VENDOR_TYPE)
+					override_rsnxe = &elem->id;
+			}
+		}
+		wpa_hexdump(MSG_DEBUG, "EAPOL-Key msg 3/4 IEs before edits",
+			    wpa_ie, wpa_ie_len);
+		wpa_ie_buf3 = os_malloc(wpa_ie_len);
+		if (!wpa_ie_buf3)
+			goto done;
+		pos = wpa_ie_buf3;
+		if (override_rsne) {
+			*pos++ = WLAN_EID_RSN;
+			*pos++ = override_rsne[1] - 4;
+			os_memcpy(pos, &override_rsne[2 + 4],
+				  override_rsne[1] - 4);
+			pos += override_rsne[1] - 4;
+		}
+		if (mde) {
+			os_memcpy(pos, mde, 2 + mde[1]);
+			pos += 2 + mde[1];
+		}
+		if (fte) {
+			os_memcpy(pos, fte, 2 + fte[1]);
+			pos += 2 + fte[1];
+		}
+		if (tie) {
+			os_memcpy(pos, tie, 2 + tie[1]);
+			pos += 2 + tie[1];
+		}
+		if (tie2) {
+			os_memcpy(pos, tie2, 2 + tie2[1]);
+			pos += 2 + tie2[1];
+		}
+		if (override_rsnxe) {
+			*pos++ = WLAN_EID_RSNX;
+			*pos++ = override_rsnxe[1] - 4;
+			os_memcpy(pos, &override_rsnxe[2 + 4],
+				  override_rsnxe[1] - 4);
+			pos += override_rsnxe[1] - 4;
+		}
+		wpa_ie = wpa_ie_buf3;
+		wpa_ie_len = pos - wpa_ie_buf3;
+		wpa_hexdump(MSG_DEBUG, "EAPOL-Key msg 3/4 IEs after edits",
+			    wpa_ie, wpa_ie_len);
+	}
 #ifdef CONFIG_TESTING_OPTIONS
 	if (conf->rsne_override_eapol_set) {
 		wpa_ie_buf2 = replace_ie(
@@ -3913,6 +3984,7 @@
 	bin_clear_free(kde, kde_len);
 	os_free(wpa_ie_buf);
 	os_free(wpa_ie_buf2);
+	os_free(wpa_ie_buf3);
 }
 
 
@@ -5767,6 +5839,13 @@
 }
 
 
+void wpa_auth_set_rsn_override(struct wpa_state_machine *sm, bool val)
+{
+	if (sm)
+		sm->rsn_override = val;
+}
+
+
 #ifdef CONFIG_DPP2
 void wpa_auth_set_dpp_z(struct wpa_state_machine *sm, const struct wpabuf *z)
 {
Index: hostapd-2022-07-29-b704dc72/src/ap/wpa_auth.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/wpa_auth.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/wpa_auth.h	2024-11-20 12:19:55.415862000 +0800
@@ -175,6 +175,7 @@
 	int wpa;
 	int extended_key_id;
 	int wpa_key_mgmt;
+	int rsn_override_key_mgmt;
 	int wpa_pairwise;
 	int wpa_group;
 	int wpa_group_rekey;
@@ -186,6 +187,7 @@
 	u32 wpa_pairwise_update_count;
 	int wpa_disable_eapol_key_retries;
 	int rsn_pairwise;
+	int rsn_override_pairwise;
 	int rsn_preauth;
 	int eapol_version;
 	int wmm_enabled;
@@ -194,6 +196,7 @@
 	int okc;
 	int tx_status;
 	enum mfp_options ieee80211w;
+	enum mfp_options rsn_override_mfp;
 	int beacon_prot;
 	int group_mgmt_cipher;
 	int sae_require_mfp;
@@ -566,6 +569,7 @@
 bool wpa_auth_write_fd_rsn_info(struct wpa_authenticator *wpa_auth,
 				u8 *fd_rsn_info);
 void wpa_auth_set_auth_alg(struct wpa_state_machine *sm, u16 auth_alg);
+void wpa_auth_set_rsn_override(struct wpa_state_machine *sm, bool val);
 void wpa_auth_set_dpp_z(struct wpa_state_machine *sm, const struct wpabuf *z);
 void wpa_auth_set_transition_disable(struct wpa_authenticator *wpa_auth,
 				     u8 val);
Index: hostapd-2022-07-29-b704dc72/src/ap/wpa_auth_glue.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/wpa_auth_glue.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/wpa_auth_glue.c	2024-11-20 12:19:55.423925000 +0800
@@ -45,6 +45,7 @@
 	wconf->wpa = conf->wpa;
 	wconf->extended_key_id = conf->extended_key_id;
 	wconf->wpa_key_mgmt = conf->wpa_key_mgmt;
+	wconf->rsn_override_key_mgmt = conf->rsn_override_key_mgmt;
 	wconf->wpa_pairwise = conf->wpa_pairwise;
 	wconf->wpa_group = conf->wpa_group;
 	wconf->wpa_group_rekey = conf->wpa_group_rekey;
@@ -56,6 +57,7 @@
 		conf->wpa_disable_eapol_key_retries;
 	wconf->wpa_pairwise_update_count = conf->wpa_pairwise_update_count;
 	wconf->rsn_pairwise = conf->rsn_pairwise;
+	wconf->rsn_override_pairwise = conf->rsn_override_pairwise;
 	wconf->rsn_preauth = conf->rsn_preauth;
 	wconf->eapol_version = conf->eapol_version;
 #ifdef CONFIG_MACSEC
@@ -70,6 +72,7 @@
 #endif /* CONFIG_OCV */
 	wconf->okc = conf->okc;
 	wconf->ieee80211w = conf->ieee80211w;
+	wconf->rsn_override_mfp = conf->rsn_override_mfp;
 	wconf->beacon_prot = conf->beacon_prot;
 	wconf->group_mgmt_cipher = conf->group_mgmt_cipher;
 	wconf->sae_require_mfp = conf->sae_require_mfp;
@@ -361,13 +364,13 @@
 #endif /* CONFIG_SAE */
 
 #ifdef CONFIG_OWE
-	if ((hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) &&
+	if (((hapd->conf->wpa_key_mgmt | hapd->conf->rsn_override_key_mgmt) & WPA_KEY_MGMT_OWE) &&
 	    sta && sta->owe_pmk) {
 		if (psk_len)
 			*psk_len = sta->owe_pmk_len;
 		return sta->owe_pmk;
 	}
-	if ((hapd->conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) && sta) {
+	if (((hapd->conf->wpa_key_mgmt | hapd->conf->rsn_override_key_mgmt) & WPA_KEY_MGMT_OWE) && sta) {
 		struct rsn_pmksa_cache_entry *sa;
 
 		sa = wpa_auth_sta_get_pmksa(sta->wpa_sm);
Index: hostapd-2022-07-29-b704dc72/src/ap/wpa_auth_i.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/wpa_auth_i.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/wpa_auth_i.h	2024-11-20 12:19:55.431795000 +0800
@@ -135,6 +135,8 @@
 	u32 dot11RSNAStatsTKIPLocalMICFailures;
 	u32 dot11RSNAStatsTKIPRemoteMICFailures;
 
+	bool rsn_override;
+
 #ifdef CONFIG_IEEE80211R_AP
 	u8 xxkey[PMK_LEN_MAX]; /* PSK or the second 256 bits of MSK, or the
 				* first 384 bits of MSK */
@@ -249,6 +251,9 @@
 	u8 *wpa_ie;
 	size_t wpa_ie_len;
 
+	u8 *rsne_override; /* RSNE with overridden payload */
+	u8 *rsnxe_override; /* RSNXE with overridden payload */
+
 	u8 addr[ETH_ALEN];
 
 	struct rsn_pmksa_cache *pmksa;
Index: hostapd-2022-07-29-b704dc72/src/ap/wpa_auth_ie.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ap/wpa_auth_ie.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ap/wpa_auth_ie.c	2024-11-20 12:19:55.438870000 +0800
@@ -88,7 +88,8 @@
 }
 
 
-static u16 wpa_own_rsn_capab(struct wpa_auth_config *conf)
+static u16 wpa_own_rsn_capab(struct wpa_auth_config *conf,
+			    enum mfp_options mfp)
 {
 	u16 capab = 0;
 
@@ -98,9 +99,9 @@
 		/* 4 PTKSA replay counters when using WMM */
 		capab |= (RSN_NUM_REPLAY_COUNTERS_16 << 2);
 	}
-	if (conf->ieee80211w != NO_MGMT_FRAME_PROTECTION) {
+	if (mfp != NO_MGMT_FRAME_PROTECTION) {
 		capab |= WPA_CAPABILITY_MFPC;
-		if (conf->ieee80211w == MGMT_FRAME_PROTECTION_REQUIRED)
+		if (mfp == MGMT_FRAME_PROTECTION_REQUIRED)
 			capab |= WPA_CAPABILITY_MFPR;
 	}
 #ifdef CONFIG_OCV
@@ -118,24 +119,19 @@
 }
 
 
-int wpa_write_rsn_ie(struct wpa_auth_config *conf, u8 *buf, size_t len,
-		     const u8 *pmkid)
+static u8 * rsne_write_data(u8 *buf, size_t len, u8 *pos, int group,
+			    int pairwise, int key_mgmt, u16 rsn_capab,
+			    const u8 *pmkid, enum mfp_options mfp,
+			    int group_mgmt_cipher)
 {
-	struct rsn_ie_hdr *hdr;
 	int num_suites, res;
-	u8 *pos, *count;
+	u8 *count;
 	u32 suite;
 
-	hdr = (struct rsn_ie_hdr *) buf;
-	hdr->elem_id = WLAN_EID_RSN;
-	WPA_PUT_LE16(hdr->version, RSN_VERSION);
-	pos = (u8 *) (hdr + 1);
-
-	suite = wpa_cipher_to_suite(WPA_PROTO_RSN, conf->wpa_group);
+	suite = wpa_cipher_to_suite(WPA_PROTO_RSN, group);
 	if (suite == 0) {
-		wpa_printf(MSG_DEBUG, "Invalid group cipher (%d).",
-			   conf->wpa_group);
-		return -1;
+		wpa_printf(MSG_DEBUG, "Invalid group cipher (%d).", group);
+		return NULL;
 	}
 	RSN_SELECTOR_PUT(pos, suite);
 	pos += RSN_SELECTOR_LEN;
@@ -152,7 +148,7 @@
 	}
 #endif /* CONFIG_RSN_TESTING */
 
-	res = rsn_cipher_put_suites(pos, conf->rsn_pairwise);
+	res = rsn_cipher_put_suites(pos, pairwise);
 	num_suites += res;
 	pos += res * RSN_SELECTOR_LEN;
 
@@ -166,8 +162,8 @@
 
 	if (num_suites == 0) {
 		wpa_printf(MSG_DEBUG, "Invalid pairwise cipher (%d).",
-			   conf->rsn_pairwise);
-		return -1;
+			   pairwise);
+		return NULL;
 	}
 	WPA_PUT_LE16(count, num_suites);
 
@@ -183,95 +179,102 @@
 	}
 #endif /* CONFIG_RSN_TESTING */
 
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X) {
+	if (key_mgmt & WPA_KEY_MGMT_IEEE8021X) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_UNSPEC_802_1X);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK) {
+	if (key_mgmt & WPA_KEY_MGMT_PSK) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_PSK_OVER_802_1X);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #ifdef CONFIG_IEEE80211R_AP
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_IEEE8021X) {
+	if (key_mgmt & WPA_KEY_MGMT_FT_IEEE8021X) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FT_802_1X);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #ifdef CONFIG_SHA384
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_IEEE8021X_SHA384) {
+	if (key_mgmt & WPA_KEY_MGMT_FT_IEEE8021X_SHA384) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FT_802_1X_SHA384);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #endif /* CONFIG_SHA384 */
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_PSK) {
+	if (key_mgmt & WPA_KEY_MGMT_FT_PSK) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FT_PSK);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #endif /* CONFIG_IEEE80211R_AP */
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X_SHA256) {
+#ifdef CONFIG_SHA384
+	if (key_mgmt & WPA_KEY_MGMT_IEEE8021X_SHA384) {
+		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_802_1X_SHA384);
+		pos += RSN_SELECTOR_LEN;
+		num_suites++;
+	}
+#endif /* CONFIG_SHA384 */
+	if (key_mgmt & WPA_KEY_MGMT_IEEE8021X_SHA256) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_802_1X_SHA256);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK_SHA256) {
+	if (key_mgmt & WPA_KEY_MGMT_PSK_SHA256) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_PSK_SHA256);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #ifdef CONFIG_SAE
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_SAE) {
+	if (key_mgmt & WPA_KEY_MGMT_SAE) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_SAE);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_SAE_EXT_KEY) {
+	if (key_mgmt & WPA_KEY_MGMT_SAE_EXT_KEY) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_SAE_EXT_KEY);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_SAE) {
+	if (key_mgmt & WPA_KEY_MGMT_FT_SAE) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FT_SAE);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_SAE_EXT_KEY) {
+	if (key_mgmt & WPA_KEY_MGMT_FT_SAE_EXT_KEY) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FT_SAE_EXT_KEY);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #endif /* CONFIG_SAE */
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X_SUITE_B) {
+	if (key_mgmt & WPA_KEY_MGMT_IEEE8021X_SUITE_B) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_802_1X_SUITE_B);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X_SUITE_B_192) {
+	if (key_mgmt & WPA_KEY_MGMT_IEEE8021X_SUITE_B_192) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_802_1X_SUITE_B_192);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #ifdef CONFIG_FILS
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FILS_SHA256) {
+	if (key_mgmt & WPA_KEY_MGMT_FILS_SHA256) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FILS_SHA256);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FILS_SHA384) {
+	if (key_mgmt & WPA_KEY_MGMT_FILS_SHA384) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FILS_SHA384);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #ifdef CONFIG_IEEE80211R_AP
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_FILS_SHA256) {
+	if (key_mgmt & WPA_KEY_MGMT_FT_FILS_SHA256) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FT_FILS_SHA256);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_FT_FILS_SHA384) {
+	if (key_mgmt & WPA_KEY_MGMT_FT_FILS_SHA384) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_FT_FILS_SHA384);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
@@ -279,28 +282,28 @@
 #endif /* CONFIG_IEEE80211R_AP */
 #endif /* CONFIG_FILS */
 #ifdef CONFIG_OWE
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_OWE) {
+	if (key_mgmt & WPA_KEY_MGMT_OWE) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_OWE);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #endif /* CONFIG_OWE */
 #ifdef CONFIG_DPP
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_DPP) {
+	if (key_mgmt & WPA_KEY_MGMT_DPP) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_DPP);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #endif /* CONFIG_DPP */
 #ifdef CONFIG_HS20
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_OSEN) {
+	if (key_mgmt & WPA_KEY_MGMT_OSEN) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_OSEN);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
 	}
 #endif /* CONFIG_HS20 */
 #ifdef CONFIG_PASN
-	if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PASN) {
+	if (key_mgmt & WPA_KEY_MGMT_PASN) {
 		RSN_SELECTOR_PUT(pos, RSN_AUTH_KEY_MGMT_PASN);
 		pos += RSN_SELECTOR_LEN;
 		num_suites++;
@@ -317,18 +320,18 @@
 
 	if (num_suites == 0) {
 		wpa_printf(MSG_DEBUG, "Invalid key management type (%d).",
-			   conf->wpa_key_mgmt);
-		return -1;
+			   key_mgmt);
+		return NULL;
 	}
 	WPA_PUT_LE16(count, num_suites);
 
 	/* RSN Capabilities */
-	WPA_PUT_LE16(pos, wpa_own_rsn_capab(conf));
+	WPA_PUT_LE16(pos, rsn_capab);
 	pos += 2;
 
 	if (pmkid) {
 		if (2 + PMKID_LEN > buf + len - pos)
-			return -1;
+			return NULL;
 		/* PMKID Count */
 		WPA_PUT_LE16(pos, 1);
 		pos += 2;
@@ -336,18 +339,19 @@
 		pos += PMKID_LEN;
 	}
 
-	if (conf->ieee80211w != NO_MGMT_FRAME_PROTECTION &&
-	    conf->group_mgmt_cipher != WPA_CIPHER_AES_128_CMAC) {
+
+	if (mfp != NO_MGMT_FRAME_PROTECTION &&
+	    group_mgmt_cipher != WPA_CIPHER_AES_128_CMAC) {
 		if (2 + 4 > buf + len - pos)
-			return -1;
-		if (pmkid == NULL) {
+			return NULL;
+		if (!pmkid) {
 			/* PMKID Count */
 			WPA_PUT_LE16(pos, 0);
 			pos += 2;
 		}
 
 		/* Management Group Cipher Suite */
-		switch (conf->group_mgmt_cipher) {
+		switch (group_mgmt_cipher) {
 		case WPA_CIPHER_AES_128_CMAC:
 			RSN_SELECTOR_PUT(pos, RSN_CIPHER_SUITE_AES_128_CMAC);
 			break;
@@ -363,8 +367,8 @@
 		default:
 			wpa_printf(MSG_DEBUG,
 				   "Invalid group management cipher (0x%x)",
-				   conf->group_mgmt_cipher);
-			return -1;
+				   group_mgmt_cipher);
+			return NULL;
 		}
 		pos += RSN_SELECTOR_LEN;
 	}
@@ -376,12 +380,12 @@
 		 * the element.
 		 */
 		int pmkid_count_set = pmkid != NULL;
-		if (conf->ieee80211w != NO_MGMT_FRAME_PROTECTION)
+		if (mfp != NO_MGMT_FRAME_PROTECTION)
 			pmkid_count_set = 1;
 		/* PMKID Count */
 		WPA_PUT_LE16(pos, 0);
 		pos += 2;
-		if (conf->ieee80211w == NO_MGMT_FRAME_PROTECTION) {
+		if (mfp == NO_MGMT_FRAME_PROTECTION) {
 			/* Management Group Cipher Suite */
 			RSN_SELECTOR_PUT(pos, RSN_CIPHER_SUITE_AES_128_CMAC);
 			pos += RSN_SELECTOR_LEN;
@@ -391,6 +395,27 @@
 		pos += 17;
 	}
 #endif /* CONFIG_RSN_TESTING */
+	return pos;
+}
+
+
+int wpa_write_rsn_ie(struct wpa_auth_config *conf, u8 *buf, size_t len,
+		     const u8 *pmkid)
+{
+	struct rsn_ie_hdr *hdr;
+	u8 *pos;
+
+	hdr = (struct rsn_ie_hdr *) buf;
+	hdr->elem_id = WLAN_EID_RSN;
+	WPA_PUT_LE16(hdr->version, RSN_VERSION);
+	pos = (u8 *) (hdr + 1);
+
+	pos = rsne_write_data(buf, len, pos, conf->wpa_group,
+			      conf->rsn_pairwise, conf->wpa_key_mgmt,
+			      wpa_own_rsn_capab(conf, conf->ieee80211w), pmkid,
+			      conf->ieee80211w, conf->group_mgmt_cipher);
+	if (!pos)
+		return -1;
 
 	hdr->len = (pos - buf) - 2;
 
@@ -398,15 +423,44 @@
 }
 
 
-int wpa_write_rsnxe(struct wpa_auth_config *conf, u8 *buf, size_t len)
+static int wpa_write_rsne_override(struct wpa_auth_config *conf, u8 *buf,
+				   size_t len)
+{
+	u8 *pos, *len_pos;
+
+	pos = buf;
+	*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+	len_pos = pos++;
+
+	WPA_PUT_BE32(pos, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+	pos += 4;
+
+	WPA_PUT_LE16(pos, RSN_VERSION);
+	pos += 2;
+
+	pos = rsne_write_data(buf, len, pos, conf->wpa_group,
+			      conf->rsn_override_pairwise,
+			      conf->rsn_override_key_mgmt,
+			      wpa_own_rsn_capab(conf, conf->rsn_override_mfp),
+			      NULL, conf->rsn_override_mfp,
+			      conf->group_mgmt_cipher);
+	if (!pos)
+		return -1;
+
+	*len_pos = (pos - buf) - 2;
+
+	return pos - buf;
+}
+
+
+static u16 rsnxe_capab(struct wpa_auth_config *conf, int key_mgmt)
 {
-	u8 *pos = buf;
 	u16 capab = 0;
-	size_t flen;
 
-	if (wpa_key_mgmt_sae(conf->wpa_key_mgmt) &&
-	    (conf->sae_pwe == 1 || conf->sae_pwe == 2 || conf->sae_pk ||
-	     wpa_key_mgmt_sae_ext_key(conf->wpa_key_mgmt))) {
+	if (wpa_key_mgmt_sae(key_mgmt) &&
+	    (conf->sae_pwe == SAE_PWE_HASH_TO_ELEMENT ||
+	     conf->sae_pwe == SAE_PWE_BOTH || conf->sae_pk ||
+	     wpa_key_mgmt_sae_ext_key(key_mgmt))) {
 		capab |= BIT(WLAN_RSNX_CAPAB_SAE_H2E);
 #ifdef CONFIG_SAE_PK
 		if (conf->sae_pk)
@@ -419,7 +473,19 @@
 	if (conf->secure_rtt)
 		capab |= BIT(WLAN_RSNX_CAPAB_SECURE_RTT);
 	if (conf->prot_range_neg)
-		capab |= BIT(WLAN_RSNX_CAPAB_PROT_RANGE_NEG);
+		capab |= BIT(WLAN_RSNX_CAPAB_URNM_MFPR);
+
+	return capab;
+}
+
+
+int wpa_write_rsnxe(struct wpa_auth_config *conf, u8 *buf, size_t len)
+{
+	u8 *pos = buf;
+	u16 capab;
+	size_t flen;
+
+	capab = rsnxe_capab(conf, conf->wpa_key_mgmt);
 
 	flen = (capab & 0xff00) ? 2 : 1;
 	if (!capab)
@@ -439,6 +505,36 @@
 }
 
 
+static int wpa_write_rsnxe_override(struct wpa_auth_config *conf, u8 *buf,
+				    size_t len)
+{
+	u8 *pos = buf;
+	u16 capab;
+	size_t flen;
+
+	capab = rsnxe_capab(conf, conf->rsn_override_key_mgmt);
+
+	flen = (capab & 0xff00) ? 2 : 1;
+	if (!capab)
+		return 0; /* no supported extended RSN capabilities */
+	if (len < 2 + flen)
+		return -1;
+	capab |= flen - 1; /* bit 0-3 = Field length (n - 1) */
+
+	*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+	*pos++ = 4 + flen;
+	WPA_PUT_BE32(pos, RSNXE_OVERRIDE_IE_VENDOR_TYPE);
+	pos += 4;
+
+	*pos++ = capab & 0x00ff;
+	capab >>= 8;
+	if (capab)
+		*pos++ = capab;
+
+	return pos - buf;
+}
+
+
 static u8 * wpa_write_osen(struct wpa_auth_config *conf, u8 *eid)
 {
 	u8 *len;
@@ -492,7 +588,7 @@
 
 int wpa_auth_gen_wpa_ie(struct wpa_authenticator *wpa_auth)
 {
-	u8 *pos, buf[128];
+	u8 *pos, buf[256];
 	int res;
 
 #ifdef CONFIG_TESTING_OPTIONS
@@ -546,6 +642,20 @@
 		pos += res;
 	}
 
+	if ((wpa_auth->conf.wpa & WPA_PROTO_RSN) &&
+	    wpa_auth->conf.rsn_override_key_mgmt) {
+		res = wpa_write_rsne_override(&wpa_auth->conf,
+					      pos, buf + sizeof(buf) - pos);
+		if (res < 0)
+			return res;
+		pos += res;
+		res = wpa_write_rsnxe_override(&wpa_auth->conf, pos,
+					       buf + sizeof(buf) - pos);
+		if (res < 0)
+			return res;
+		pos += res;
+	}
+
 	os_free(wpa_auth->wpa_ie);
 	wpa_auth->wpa_ie = os_malloc(pos - buf);
 	if (wpa_auth->wpa_ie == NULL)
@@ -553,6 +663,39 @@
 	os_memcpy(wpa_auth->wpa_ie, buf, pos - buf);
 	wpa_auth->wpa_ie_len = pos - buf;
 
+	if ((wpa_auth->conf.wpa & WPA_PROTO_RSN) &&
+	    wpa_auth->conf.rsn_override_key_mgmt) {
+		res = wpa_write_rsne_override(&wpa_auth->conf, buf,
+					      sizeof(buf));
+		if (res < 0)
+			return res;
+		os_free(wpa_auth->rsne_override);
+		wpa_auth->rsne_override = os_malloc(res - 4);
+		if (!wpa_auth->rsne_override)
+			return -1;
+		pos = wpa_auth->rsne_override;
+		*pos++ = WLAN_EID_RSN;
+		*pos++ = res - 2 - 4;
+		os_memcpy(pos, &buf[2 + 4], res - 2 - 4);
+
+		res = wpa_write_rsnxe_override(&wpa_auth->conf, buf,
+					       sizeof(buf));
+		if (res < 0)
+			return res;
+		os_free(wpa_auth->rsnxe_override);
+		if (res == 0) {
+			wpa_auth->rsnxe_override = NULL;
+			return 0;
+		}
+		wpa_auth->rsnxe_override = os_malloc(res - 4);
+		if (!wpa_auth->rsnxe_override)
+			return -1;
+		pos = wpa_auth->rsnxe_override;
+		*pos++ = WLAN_EID_RSNX;
+		*pos++ = res - 2 - 4;
+		os_memcpy(pos, &buf[2 + 4], res - 2 - 4);
+	}
+
 	return 0;
 }
 
@@ -752,7 +895,8 @@
 		return WPA_INVALID_GROUP;
 	}
 
-	key_mgmt = data.key_mgmt & wpa_auth->conf.wpa_key_mgmt;
+	key_mgmt = data.key_mgmt & (wpa_auth->conf.wpa_key_mgmt |
+				    wpa_auth->conf.rsn_override_key_mgmt);
 	if (!key_mgmt) {
 		wpa_printf(MSG_DEBUG, "Invalid WPA key mgmt (0x%x) from "
 			   MACSTR, data.key_mgmt, MAC2STR(sm->addr));
@@ -818,7 +962,9 @@
 		sm->wpa_key_mgmt = WPA_KEY_MGMT_PSK;
 
 	if (version == WPA_PROTO_RSN)
-		ciphers = data.pairwise_cipher & wpa_auth->conf.rsn_pairwise;
+		ciphers = data.pairwise_cipher &
+			(wpa_auth->conf.rsn_pairwise |
+			 wpa_auth->conf.rsn_override_pairwise);
 	else
 		ciphers = data.pairwise_cipher & wpa_auth->conf.wpa_pairwise;
 	if (!ciphers) {
@@ -1181,7 +1327,7 @@
 		return false;
 
 	/* RSN Capability (B0..B15) */
-	WPA_PUT_LE16(pos, wpa_own_rsn_capab(conf));
+	WPA_PUT_LE16(pos, wpa_own_rsn_capab(conf, conf->ieee80211w));
 	pos += 2;
 
 	/* Group Data Cipher Suite Selector (B16..B21) */
Index: hostapd-2022-07-29-b704dc72/src/common/defs.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/common/defs.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/common/defs.h	2024-11-20 12:19:55.446870000 +0800
@@ -52,6 +52,7 @@
 #define WPA_KEY_MGMT_PASN BIT(25)
 #define WPA_KEY_MGMT_SAE_EXT_KEY BIT(26)
 #define WPA_KEY_MGMT_FT_SAE_EXT_KEY BIT(27)
+#define WPA_KEY_MGMT_IEEE8021X_SHA384 BIT(28)
 
 
 #define WPA_KEY_MGMT_FT (WPA_KEY_MGMT_FT_PSK | \
@@ -511,4 +512,12 @@
 	FRAME_ENCRYPTED = 1
 };
 
+enum sae_pwe {
+	SAE_PWE_HUNT_AND_PECK = 0,
+	SAE_PWE_HASH_TO_ELEMENT = 1,
+	SAE_PWE_BOTH = 2,
+	SAE_PWE_FORCE_HUNT_AND_PECK = 3,
+	SAE_PWE_NOT_SET = 4,
+};
+
 #endif /* DEFS_H */
Index: hostapd-2022-07-29-b704dc72/src/common/ieee802_11_common.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/common/ieee802_11_common.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/common/ieee802_11_common.c	2024-11-20 12:19:55.456898000 +0800
@@ -140,6 +140,10 @@
 			elems->sae_pk = pos + 4;
 			elems->sae_pk_len = elen - 4;
 			break;
+		case WFA_RSNE_OVERRIDE_OUI_TYPE:
+			elems->rsne_override = pos;
+			elems->rsne_override_len = elen;
+			break;
 		default:
 			wpa_printf(MSG_MSGDUMP, "Unknown WFA "
 				   "information element ignored "
@@ -179,6 +183,10 @@
 			elems->pref_freq_list = pos;
 			elems->pref_freq_list_len = elen;
 			break;
+		case QCA_VENDOR_ELEM_RSNE_OVERRIDE:
+			elems->rsne_override = pos;
+			elems->rsne_override_len = elen;
+			break;
 		default:
 			wpa_printf(MSG_EXCESSIVE,
 				   "Unknown QCA information element ignored (type=%d len=%lu)",
@@ -2491,8 +2499,12 @@
 
 bool ieee802_11_rsnx_capab(const u8 *rsnxe, unsigned int capab)
 {
-	return ieee802_11_rsnx_capab_len(rsnxe ? rsnxe + 2 : NULL,
-					 rsnxe ? rsnxe[1] : 0, capab);
+	if (!rsnxe)
+		return false;
+	if (rsnxe[0] == WLAN_EID_VENDOR_SPECIFIC && rsnxe[1] >= 4 + 1)
+		return ieee802_11_rsnx_capab_len(rsnxe + 2 + 4, rsnxe[1] - 4,
+						 capab);
+	return ieee802_11_rsnx_capab_len(rsnxe + 2, rsnxe[1], capab);
 }
 
 
Index: hostapd-2022-07-29-b704dc72/src/common/ieee802_11_common.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/common/ieee802_11_common.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/common/ieee802_11_common.h	2024-11-20 12:19:55.467801000 +0800
@@ -123,6 +123,7 @@
 #ifdef CONFIG_MTK_IEEE80211BE
 	const u8 *ml;
 #endif
+	const u8 *rsne_override;
 
 	u8 ssid_len;
 	u8 supp_rates_len;
@@ -182,6 +183,7 @@
 #ifdef CONFIG_MTK_IEEE80211BE
 	u8 ml_len;
 #endif
+	size_t rsne_override_len;
 
 	struct mb_ies_info mb_ies;
 	struct frag_ies_info frag_ies;
Index: hostapd-2022-07-29-b704dc72/src/common/ieee802_11_defs.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/common/ieee802_11_defs.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/common/ieee802_11_defs.h	2024-11-20 12:19:55.476786000 +0800
@@ -596,6 +596,7 @@
 #define WLAN_RSNX_CAPAB_SECURE_LTF 8
 #define WLAN_RSNX_CAPAB_SECURE_RTT 9
 #define WLAN_RSNX_CAPAB_PROT_RANGE_NEG 10
+#define WLAN_RSNX_CAPAB_URNM_MFPR 15
 
 /* Action frame categories (IEEE Std 802.11-2016, 9.4.1.11, Table 9-76) */
 #define WLAN_ACTION_SPECTRUM_MGMT 0
@@ -1376,6 +1377,15 @@
 #define QM_IE_OUI_TYPE 0x22
 #define WFA_CAPA_IE_VENDOR_TYPE 0x506f9a23
 #define WFA_CAPA_OUI_TYPE 0x23
+#define WFA_RSNE_OVERRIDE_OUI_TYPE 0x26
+#define WFA_RSNXE_OVERRIDE_OUI_TYPE 0x27
+#if 1
+#define RSNE_OVERRIDE_IE_VENDOR_TYPE 0x506f9a26
+#define RSNXE_OVERRIDE_IE_VENDOR_TYPE 0x506f9a27
+#else
+#define RSNE_OVERRIDE_IE_VENDOR_TYPE 0x00137407
+#define RSNXE_OVERRIDE_IE_VENDOR_TYPE 0x00137408
+#endif
 
 #define MULTI_AP_SUB_ELEM_TYPE 0x06
 #define MULTI_AP_TEAR_DOWN BIT(4)
Index: hostapd-2022-07-29-b704dc72/src/common/qca-vendor.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/common/qca-vendor.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/common/qca-vendor.h	2024-11-20 12:19:55.506933000 +0800
@@ -2077,6 +2077,18 @@
  *	change.
  *
  *  @QCA_VENDOR_ELEM_ALLPLAY: Allplay element
+ *
+ * @QCA_VS_ELEM_RSNE_OVERRIDE: RSNE override
+ *	Used in BSS discovery phase frames (e.g., Beacon and Probe Response
+ *	frame) to indicate available RSN options for STAs that support the
+ *	override mechanism. Payload is encoded identically to RSNE. Also used
+ *	in (Re)Association Request frame to indicate support for RSNE
+ *	overriding.
+ *
+ * @QCA_VS_ELEM_RSNXE_OVERRIDE: RSNXE override
+ *	Used in BSS discovery phase frames (e.g., Beacon and Probe Response
+ *	frame) to indicate available RSN options for STAs that support the
+ *	override mechanism. Payload is encoded identically to RSNXE.
  */
 enum qca_vendor_element_id {
 	QCA_VENDOR_ELEM_P2P_PREF_CHAN_LIST = 0,
@@ -2086,6 +2098,8 @@
 	QCA_VENDOR_ELEM_MU_EDCA_PARAMS = 4,
 	QCA_VENDOR_ELEM_BSS_COLOR_CHANGE = 5,
 	QCA_VENDOR_ELEM_ALLPLAY = 6,
+	QCA_VENDOR_ELEM_RSNE_OVERRIDE = 7,
+	QCA_VENDOR_ELEM_RSNXE_OVERRIDE = 8,
 };
 
 /**
Index: hostapd-2022-07-29-b704dc72/src/common/wpa_common.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/common/wpa_common.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/common/wpa_common.c	2024-11-20 12:19:55.516800000 +0800
@@ -1988,6 +1988,12 @@
 		data->has_group = 1;
 		data->key_mgmt = WPA_KEY_MGMT_OSEN;
 		data->proto = WPA_PROTO_OSEN;
+	} else if (rsn_ie_len >= 2 + 4 + 2 && rsn_ie[1] >= 4 + 2 &&
+		   rsn_ie[1] == rsn_ie_len - 2 &&
+		   WPA_GET_BE32(&rsn_ie[2]) == RSNE_OVERRIDE_IE_VENDOR_TYPE &&
+		   WPA_GET_LE16(&rsn_ie[2 + 4]) == RSN_VERSION) {
+		pos = rsn_ie + 2 + 4 + 2;
+		left = rsn_ie_len - 2 - 4 - 2;
 	} else {
 		const struct rsn_ie_hdr *hdr;
 
Index: hostapd-2022-07-29-b704dc72/src/drivers/driver_nl80211.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/drivers/driver_nl80211.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/drivers/driver_nl80211.c	2024-11-20 12:19:55.542810000 +0800
@@ -6371,9 +6371,25 @@
 	}
 
 	wpa_hexdump(MSG_DEBUG, "  * IEs", params->wpa_ie, params->wpa_ie_len);
-	if (params->wpa_ie &&
-	    nla_put(msg, NL80211_ATTR_IE, params->wpa_ie_len, params->wpa_ie))
+	if (drv->rsn_override && params->wpa_ie) {
+		u8 *pos, *ies = os_malloc(params->wpa_ie_len + 6);
+
+		if (!ies)
+			return -1;
+
+		os_memcpy(ies, params->wpa_ie, params->wpa_ie_len);
+		pos = &ies[params->wpa_ie_len];
+		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+		*pos++ = 4;
+		WPA_PUT_BE32(pos, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+		if (nla_put(msg, NL80211_ATTR_IE, params->wpa_ie_len + 6, ies))
+			return -1;
+		os_free(ies);
+	} else if (params->wpa_ie &&
+		   nla_put(msg, NL80211_ATTR_IE, params->wpa_ie_len,
+			   params->wpa_ie)) {
 		return -1;
+	}
 
 	if (params->wpa_proto) {
 		enum nl80211_wpa_versions ver = 0;
@@ -9066,6 +9082,9 @@
 		}
 	}
 
+	if (os_strstr(param, "rsn_override=1"))
+		drv->rsn_override = 1;
+
 	return 0;
 }
 
Index: hostapd-2022-07-29-b704dc72/src/drivers/driver_nl80211.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/drivers/driver_nl80211.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/drivers/driver_nl80211.h	2024-11-20 12:20:22.028936000 +0800
@@ -182,6 +182,7 @@
 	unsigned int qca_do_acs:1;
 	unsigned int brcm_do_acs:1;
 	unsigned int uses_6ghz:1;
+	unsigned int rsn_override:1;
 
 	u64 vendor_scan_cookie;
 	u64 remain_on_chan_cookie;
Index: hostapd-2022-07-29-b704dc72/src/drivers/driver_nl80211_scan.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/drivers/driver_nl80211_scan.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/drivers/driver_nl80211_scan.c	2024-11-20 12:19:55.591841000 +0800
@@ -708,6 +708,49 @@
 	return 1;
 }
 
+static u8 * override_rsn_ies(const u8 *ie, size_t *len)
+{
+	u8 *rsne, *rsnxe, *o_rsne, *o_rsnxe;
+	u8 *buf;
+
+	if (!ie)
+		return NULL;
+
+	if (!get_vendor_ie(ie, *len, RSNE_OVERRIDE_IE_VENDOR_TYPE))
+		return NULL;
+
+	buf = os_memdup(ie, *len);
+	if (!buf)
+		return NULL;
+	rsne = (u8 *) get_ie(buf, *len, WLAN_EID_RSN);
+	rsnxe = (u8 *) get_ie(buf, *len, WLAN_EID_RSNX);
+	o_rsne = (u8 *) get_vendor_ie(buf, *len, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+	o_rsnxe = (u8 *) get_vendor_ie(buf, *len,
+				       RSNXE_OVERRIDE_IE_VENDOR_TYPE);
+	if (rsne)
+		rsne[0] = 254;
+	if (rsnxe)
+		rsnxe[0] = 254;
+
+	o_rsne[4] = WLAN_EID_RSN;
+	o_rsne[5] = o_rsne[1] - 4;
+	o_rsne[0] = 254;
+	o_rsne[1] = 2;
+	o_rsne[2] = 0xcc;
+	o_rsne[3] = 0xcc;
+
+	if (o_rsnxe) {
+		o_rsnxe[4] = WLAN_EID_RSNX;
+		o_rsnxe[5] = o_rsnxe[1] - 4;
+		o_rsnxe[0] = 254;
+		o_rsnxe[1] = 2;
+		o_rsnxe[2] = 0xee;
+		o_rsnxe[3] = 0xee;
+	}
+
+	return buf;
+}
+
 
 static struct wpa_scan_res *
 nl80211_parse_bss_info(struct wpa_driver_nl80211_data *drv,
@@ -737,6 +780,7 @@
 	const u8 *ie, *beacon_ie;
 	size_t ie_len, beacon_ie_len;
 	u8 *pos;
+	u8 *ie_buf = NULL, *beacon_ie_buf = NULL;
 
 	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
 		  genlmsg_attrlen(gnlh, 0), NULL);
@@ -748,6 +792,11 @@
 	if (bss[NL80211_BSS_INFORMATION_ELEMENTS]) {
 		ie = nla_data(bss[NL80211_BSS_INFORMATION_ELEMENTS]);
 		ie_len = nla_len(bss[NL80211_BSS_INFORMATION_ELEMENTS]);
+		if (drv->rsn_override) {
+			ie_buf = override_rsn_ies(ie, &ie_len);
+			if (ie_buf)
+				ie = ie_buf;
+		}
 	} else {
 		ie = NULL;
 		ie_len = 0;
@@ -755,18 +804,30 @@
 	if (bss[NL80211_BSS_BEACON_IES]) {
 		beacon_ie = nla_data(bss[NL80211_BSS_BEACON_IES]);
 		beacon_ie_len = nla_len(bss[NL80211_BSS_BEACON_IES]);
+		if (drv->rsn_override) {
+			beacon_ie_buf = override_rsn_ies(beacon_ie,
+							 &beacon_ie_len);
+			if (ie_buf)
+				beacon_ie = beacon_ie_buf;
+		}
 	} else {
 		beacon_ie = NULL;
 		beacon_ie_len = 0;
 	}
 
 	if (nl80211_scan_filtered(drv, ie ? ie : beacon_ie,
-				  ie ? ie_len : beacon_ie_len))
+				  ie ? ie_len : beacon_ie_len)) {
+		os_free(ie_buf);
+		os_free(beacon_ie_buf);
 		return NULL;
+	}
 
 	r = os_zalloc(sizeof(*r) + ie_len + beacon_ie_len);
-	if (r == NULL)
+	if (!r) {
+		os_free(ie_buf);
+		os_free(beacon_ie_buf);
 		return NULL;
+	}
 	if (bss[NL80211_BSS_BSSID])
 		os_memcpy(r->bssid, nla_data(bss[NL80211_BSS_BSSID]),
 			  ETH_ALEN);
@@ -842,6 +903,8 @@
 			  ETH_ALEN);
 	}
 
+	os_free(ie_buf);
+	os_free(beacon_ie_buf);
 	return r;
 }
 
Index: hostapd-2022-07-29-b704dc72/src/ml/ml_common.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ml/ml_common.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ml/ml_common.c	2024-11-20 12:19:55.599861000 +0800
@@ -93,6 +93,10 @@
 	size_t len = 1 /* Link Information */ + ETH_ALEN + rsne_len + rsnxe_len;
 
 	cp = buf = os_malloc(len);
+	if (!cp) {
+		wpa_printf(MSG_ERROR, "ML: error cp is null, alloc fail, len:%ld", len);
+		return pos;
+	}
 	os_memset(cp, 0, len);
 	*cp = link_id & BITS(0, 3);
 	if (rsne && rsne_len)
@@ -955,7 +959,8 @@
 		size_t mde_len;
 #endif
 		const u8 *rsne, *rsnxe;
-		size_t rsne_len, rsnxe_len;
+		size_t rsne_len = 0, rsnxe_len = 0;
+		u8 *rsn_tmp_buff = NULL, *rsnx_tmp_buff = NULL, *wpa_ie_buf = NULL;
 
 		link = &ml_group->links[i];
 		if (link->link_id == sm->sta_ml_ie->link_id) {
@@ -977,10 +982,60 @@
 					link->link_id, MAC2STR(link->addr));
 			return NULL;
 		}
-		rsne = get_ie(auth->wpa_ie, auth->wpa_ie_len, WLAN_EID_RSN);
-		rsne_len = rsne ? rsne[1] + 2 : 0;
-		rsnxe = get_ie(auth->wpa_ie, auth->wpa_ie_len, WLAN_EID_RSNX);
-		rsnxe_len = rsnxe ? rsnxe[1] + 2 : 0;
+
+		if (get_vendor_ie(auth->wpa_ie, auth->wpa_ie_len, RSNE_OVERRIDE_IE_VENDOR_TYPE)) {
+			const u8 *override_rsne = NULL, *override_rsnxe = NULL;
+			const struct element *elem;
+
+			for_each_element_id(elem, WLAN_EID_VENDOR_SPECIFIC,
+				    auth->wpa_ie, auth->wpa_ie_len) {
+				if (elem->datalen >= 4) {
+					if (WPA_GET_BE32(elem->data) ==
+					    RSNE_OVERRIDE_IE_VENDOR_TYPE)
+						override_rsne = &elem->id;
+					if (WPA_GET_BE32(elem->data) ==
+					    RSNXE_OVERRIDE_IE_VENDOR_TYPE)
+						override_rsnxe = &elem->id;
+				}
+			}
+			wpa_ie_buf = os_malloc(auth->wpa_ie_len);
+			if (!wpa_ie_buf) {
+				wpa_printf(MSG_ERROR, "ML: rsn_tmp_buff alloc fail");
+				return pos;
+			}
+			rsn_tmp_buff = wpa_ie_buf;
+			if (override_rsne) {
+				*rsn_tmp_buff++ = WLAN_EID_RSN;
+				*rsn_tmp_buff++ = override_rsne[1] - 4;
+				os_memcpy(rsn_tmp_buff, &override_rsne[2 + 4],
+					  override_rsne[1] - 4);
+				rsn_tmp_buff += override_rsne[1] - 4;
+
+				rsne = wpa_ie_buf;
+				rsne_len = rsn_tmp_buff - wpa_ie_buf;
+				wpa_hexdump(MSG_DEBUG, "ML: converted rsno to rsn",
+			    rsne, rsne_len);
+			}
+			rsnx_tmp_buff = rsn_tmp_buff;
+			if (override_rsnxe) {
+				*rsnx_tmp_buff++ = WLAN_EID_RSNX;
+				*rsnx_tmp_buff++ = override_rsnxe[1] - 4;
+				os_memcpy(rsnx_tmp_buff, &override_rsnxe[2 + 4],
+					  override_rsnxe[1] - 4);
+				rsnx_tmp_buff += override_rsnxe[1] - 4;
+
+				rsnxe = rsn_tmp_buff;
+				rsnxe_len = rsnx_tmp_buff - rsn_tmp_buff;
+				wpa_hexdump(MSG_DEBUG, "ML: converted rsnxo to rsnx",
+			    rsnxe, rsnxe_len);
+			}
+		} else {
+			rsne = get_ie(auth->wpa_ie, auth->wpa_ie_len, WLAN_EID_RSN);
+			rsne_len = rsne ? rsne[1] + 2 : 0;
+			rsnxe = get_ie(auth->wpa_ie, auth->wpa_ie_len, WLAN_EID_RSNX);
+			rsnxe_len = rsnxe ? rsnxe[1] + 2 : 0;
+			wpa_printf(MSG_INFO, "ML: get rsne or rsnxe in normal mode");
+		}
 
 #ifdef CONFIG_IEEE80211R_AP
 		if (wpa_key_mgmt_ft(sm->wpa_key_mgmt) && rsne) {
@@ -1027,6 +1082,7 @@
 #ifdef CONFIG_IEEE80211R_AP
 		os_free(rsn_ie_buf);
 #endif
+		os_free(wpa_ie_buf);
 	}
 
 	return pos;
Index: hostapd-2022-07-29-b704dc72/src/ml/ml_supplicant.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/ml/ml_supplicant.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/ml/ml_supplicant.c	2024-11-20 12:19:55.634889000 +0800
@@ -479,6 +479,12 @@
 
 	os_memset(wpa, 0, sizeof(*wpa));
 
+	ie = wpa_bss_get_vendor_ie(bss, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+	if (ie) {
+		wpa_printf(MSG_INFO, "ML: AP is in RSNO mode");
+		return 1;
+	}
+
 	ie = wpa_bss_get_ie(curr, WLAN_EID_RSN);
 	if (ie) {
 		wpa->ap_rsn_ie = ie;
@@ -549,6 +555,20 @@
 		mlo_link = (struct wpa_mlo_link_kde *) ie->mlo_link.kdes[i].data;
 		if (ml_get_wpa_ie(sm->ctx->ctx, mlo_link->addr, &wpa) < 0) {
 			wpa_printf(MSG_ERROR, "ML: Could not find mlo_link("MACSTR") from the scan results", MAC2STR(mlo_link->addr));
+		} else if (ml_get_wpa_ie(sm->ctx->ctx, mlo_link->addr, &wpa) == 1) {
+			wpa_printf(MSG_ERROR, "ML: debug in");
+			target_wpa = &wpa;
+			if (sm->ap_rsn_ie) {
+				target_wpa->ap_rsn_ie = sm->ap_rsn_ie;
+				target_wpa->ap_rsn_ie_len = sm->ap_rsn_ie_len;
+				wpa_printf(MSG_ERROR, "ML: debug 2");
+			}
+			if (sm->ap_rsnxe) {
+				target_wpa->ap_rsnxe = sm->ap_rsnxe;
+				target_wpa->ap_rsnxe_len = sm->ap_rsnxe_len;
+				wpa_printf(MSG_ERROR, "ML: debug 3");
+			}
+			break;
 		} else {
 			target_wpa = &wpa;
 			break;
Index: hostapd-2022-07-29-b704dc72/src/rsn_supp/wpa.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/rsn_supp/wpa.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/rsn_supp/wpa.c	2024-11-20 12:19:55.660947000 +0800
@@ -3854,11 +3854,24 @@
 		sm->ap_rsn_ie_len = 0;
 	} else {
 		wpa_hexdump(MSG_DEBUG, "WPA: set AP RSN IE", ie, len);
-		sm->ap_rsn_ie = os_memdup(ie, len);
-		if (sm->ap_rsn_ie == NULL)
-			return -1;
+		if (ie[0] == WLAN_EID_VENDOR_SPECIFIC && len > 2 + 4) {
+			sm->ap_rsn_ie = os_malloc(len - 4);
+			if (!sm->ap_rsn_ie)
+				return -1;
+			sm->ap_rsn_ie[0] = WLAN_EID_RSN;
+			sm->ap_rsn_ie[1] = len - 2 - 4;
+			os_memcpy(&sm->ap_rsn_ie[2], ie + 2 + 4, len - 2 - 4);
+			sm->ap_rsn_ie_len = len - 4;
+			wpa_hexdump(MSG_DEBUG,
+					"RSN: Converted RSNE override to RSNE",
+					sm->ap_rsn_ie, sm->ap_rsn_ie_len);
+		} else {
+			sm->ap_rsn_ie = os_memdup(ie, len);
+			if (sm->ap_rsn_ie == NULL)
+				return -1;
 
-		sm->ap_rsn_ie_len = len;
+			sm->ap_rsn_ie_len = len;
+		}
 	}
 
 	return 0;
@@ -3887,11 +3900,24 @@
 		sm->ap_rsnxe_len = 0;
 	} else {
 		wpa_hexdump(MSG_DEBUG, "WPA: set AP RSNXE", ie, len);
-		sm->ap_rsnxe = os_memdup(ie, len);
-		if (!sm->ap_rsnxe)
-			return -1;
+		if (ie[0] == WLAN_EID_VENDOR_SPECIFIC && len > 2 + 4) {
+			sm->ap_rsnxe = os_malloc(len - 4);
+			if (!sm->ap_rsnxe)
+				return -1;
+			sm->ap_rsnxe[0] = WLAN_EID_RSNX;
+			sm->ap_rsnxe[1] = len - 2 - 4;
+			os_memcpy(&sm->ap_rsnxe[2], ie + 2 + 4, len - 2 - 4);
+			sm->ap_rsnxe_len = len - 4;
+			wpa_hexdump(MSG_DEBUG,
+					"RSN: Converted RSNXE override to RSNXE",
+					sm->ap_rsnxe, sm->ap_rsnxe_len);
+		} else {
+			sm->ap_rsnxe = os_memdup(ie, len);
+			if (!sm->ap_rsnxe)
+				return -1;
 
-		sm->ap_rsnxe_len = len;
+			sm->ap_rsnxe_len = len;
+		}
 	}
 
 	return 0;
Index: hostapd-2022-07-29-b704dc72/src/rsn_supp/wpa_ie.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/src/rsn_supp/wpa_ie.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/src/rsn_supp/wpa_ie.c	2024-11-20 12:19:55.672809000 +0800
@@ -31,7 +31,11 @@
 	if (wpa_ie_len >= 1 && wpa_ie[0] == WLAN_EID_RSN)
 		return wpa_parse_wpa_ie_rsn(wpa_ie, wpa_ie_len, data);
 	if (wpa_ie_len >= 6 && wpa_ie[0] == WLAN_EID_VENDOR_SPECIFIC &&
-	    wpa_ie[1] >= 4 && WPA_GET_BE32(&wpa_ie[2]) == OSEN_IE_VENDOR_TYPE)
+		wpa_ie[1] >= 4 && WPA_GET_BE32(&wpa_ie[2]) == OSEN_IE_VENDOR_TYPE)
+		return wpa_parse_wpa_ie_rsn(wpa_ie, wpa_ie_len, data);
+	else if (wpa_ie_len >= 6 && wpa_ie[0] == WLAN_EID_VENDOR_SPECIFIC &&
+		 wpa_ie[1] >= 4 &&
+		 WPA_GET_BE32(&wpa_ie[2]) == RSNE_OVERRIDE_IE_VENDOR_TYPE)
 		return wpa_parse_wpa_ie_rsn(wpa_ie, wpa_ie_len, data);
 	else
 		return wpa_parse_wpa_ie_wpa(wpa_ie, wpa_ie_len, data);
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/bss.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/bss.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/bss.c	2024-11-20 12:19:55.713982000 +0800
@@ -24,6 +24,10 @@
 #include "ml/ml_supplicant.h"
 #endif
 
+#ifdef CONFIG_TESTING_OPTIONS
+bool wpas_disable_rsn_override = false;
+#endif /* CONFIG_TESTING_OPTIONS */
+
 static void wpa_bss_set_hessid(struct wpa_bss *bss)
 {
 #ifdef CONFIG_INTERWORKING
@@ -1420,3 +1424,35 @@
 	return ieee802_11_ext_capab(wpa_bss_get_ie(bss, WLAN_EID_EXT_CAPAB),
 				    capab);
 }
+
+const u8 * wpa_bss_get_rsne(const struct wpa_bss *bss)
+{
+	const u8 *ie;
+
+#ifdef CONFIG_TESTING_OPTIONS
+	if (wpas_disable_rsn_override)
+		return wpa_bss_get_ie(bss, WLAN_EID_RSN);
+#endif /* CONFIG_TESTING_OPTIONS */
+
+	ie = wpa_bss_get_vendor_ie(bss, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+	if (ie)
+		return ie;
+	return wpa_bss_get_ie(bss, WLAN_EID_RSN);
+}
+
+
+const u8 * wpa_bss_get_rsnxe(const struct wpa_bss *bss)
+{
+	const u8 *ie;
+
+#ifdef CONFIG_TESTING_OPTIONS
+	if (wpas_disable_rsn_override)
+		return wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+#endif /* CONFIG_TESTING_OPTIONS */
+
+	ie = wpa_bss_get_vendor_ie(bss, RSNXE_OVERRIDE_IE_VENDOR_TYPE);
+	if (ie)
+		return ie;
+	return wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+}
+
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/bss.h
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/bss.h	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/bss.h	2024-11-20 12:19:55.726014000 +0800
@@ -211,4 +211,7 @@
 			   unsigned int age_ms,
 			   struct os_reltime *update_time);
 
+const u8 * wpa_bss_get_rsne(const struct wpa_bss *bss);
+const u8 * wpa_bss_get_rsnxe(const struct wpa_bss *bss);
+
 #endif /* BSS_H */
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/ctrl_iface.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/ctrl_iface.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/ctrl_iface.c	2024-11-20 12:19:55.759895000 +0800
@@ -873,6 +873,10 @@
 	} else if (os_strcasecmp(cmd, "dpp_test") == 0) {
 		dpp_test = atoi(value);
 #endif /* CONFIG_DPP */
+	} else if (os_strcasecmp(cmd, "disable_rsn_override") == 0) {
+		extern bool wpas_disable_rsn_override;
+
+		wpas_disable_rsn_override = atoi(value);
 #endif /* CONFIG_TESTING_OPTIONS */
 #ifdef CONFIG_FILS
 	} else if (os_strcasecmp(cmd, "disable_fils") == 0) {
@@ -3042,12 +3046,12 @@
 	ie = wpa_bss_get_vendor_ie(bss, WPA_IE_VENDOR_TYPE);
 	if (ie)
 		pos = wpa_supplicant_ie_txt(pos, end, "WPA", ie, 2 + ie[1]);
-	ie2 = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	ie2 = wpa_bss_get_rsne(bss);
 	if (ie2) {
 		pos = wpa_supplicant_ie_txt(pos, end, mesh ? "RSN" : "WPA2",
 					    ie2, 2 + ie2[1]);
 	}
-	rsnxe = wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+	rsnxe = wpa_bss_get_rsnxe(bss);
 	if (ieee802_11_rsnx_capab(rsnxe, WLAN_RSNX_CAPAB_SAE_H2E)) {
 		ret = os_snprintf(pos, end - pos, "[SAE-H2E]");
 		if (os_snprintf_error(end - pos, ret))
@@ -5127,12 +5131,12 @@
 		if (ie)
 			pos = wpa_supplicant_ie_txt(pos, end, "WPA", ie,
 						    2 + ie[1]);
-		ie2 = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+		ie2 = wpa_bss_get_rsne(bss);
 		if (ie2)
 			pos = wpa_supplicant_ie_txt(pos, end,
 						    mesh ? "RSN" : "WPA2", ie2,
 						    2 + ie2[1]);
-		rsnxe = wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+		rsnxe = wpa_bss_get_rsnxe(bss);
 		if (ieee802_11_rsnx_capab(rsnxe, WLAN_RSNX_CAPAB_SAE_H2E)) {
 			ret = os_snprintf(pos, end - pos, "[SAE-H2E]");
 			if (os_snprintf_error(end - pos, ret))
@@ -8627,6 +8631,11 @@
 	wpa_s->dpp_discard_public_action = 0;
 	dpp_test = DPP_TEST_DISABLED;
 #endif /* CONFIG_DPP */
+	{
+		extern bool wpas_disable_rsn_override;
+
+		wpas_disable_rsn_override = false;
+	}
 #endif /* CONFIG_TESTING_OPTIONS */
 
 	wpa_s->disconnected = 0;
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/dbus/dbus_new_handlers.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/dbus/dbus_new_handlers.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/dbus/dbus_new_handlers.c	2024-11-20 12:19:55.769924000 +0800
@@ -5302,7 +5302,7 @@
 		return FALSE;
 
 	os_memset(&wpa_data, 0, sizeof(wpa_data));
-	ie = wpa_bss_get_ie(res, WLAN_EID_RSN);
+	ie = wpa_bss_get_rsne(res);
 	if (ie && wpa_parse_wpa_ie(ie, 2 + ie[1], &wpa_data) < 0) {
 		dbus_set_error_const(error, DBUS_ERROR_FAILED,
 				     "failed to parse RSN IE");
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/dpp_supplicant.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/dpp_supplicant.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/dpp_supplicant.c	2024-11-20 12:19:55.784831000 +0800
@@ -4336,7 +4336,7 @@
 
 	if (!(ssid->key_mgmt & WPA_KEY_MGMT_DPP) || !bss)
 		return 0; /* Not using DPP AKM - continue */
-	rsn = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	rsn = wpa_bss_get_rsne(bss);
 	if (rsn && wpa_parse_wpa_ie(rsn, 2 + rsn[1], &ied) == 0 &&
 	    !(ied.key_mgmt & WPA_KEY_MGMT_DPP))
 		return 0; /* AP does not support DPP AKM - continue */
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/events.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/events.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/events.c	2024-11-20 12:19:55.793845000 +0800
@@ -587,7 +587,7 @@
 		 (ssid->key_mgmt & WPA_KEY_MGMT_IEEE8021X_NO_WPA));
 #endif /* CONFIG_WEP */
 
-	rsn_ie = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	rsn_ie = wpa_bss_get_rsne(bss);
 	if (is_6ghz_bss && !rsn_ie) {
 		if (debug_print)
 			wpa_dbg(wpa_s, MSG_DEBUG,
@@ -1030,7 +1030,7 @@
 	struct wpa_bss *open_bss;
 
 	owe = wpa_bss_get_vendor_ie(bss, OWE_IE_VENDOR_TYPE);
-	if (!owe || !wpa_bss_get_ie(bss, WLAN_EID_RSN))
+	if (!owe || !wpa_bss_get_rsne(bss))
 		return;
 
 	pos = owe + 6;
@@ -1157,7 +1157,7 @@
 
 		if (bss == orig_bss)
 			continue;
-		ie = wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+		ie = wpa_bss_get_rsnxe(bss);
 		if (!(ieee802_11_rsnx_capab(ie, WLAN_RSNX_CAPAB_SAE_PK)))
 			continue;
 
@@ -1196,7 +1196,7 @@
 
 	ie = wpa_bss_get_vendor_ie(bss, WPA_IE_VENDOR_TYPE);
 	wpa = ie && ie[1];
-	ie = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	ie = wpa_bss_get_rsne(bss);
 	wpa |= ie && ie[1];
 	if (ie && wpa_parse_wpa_ie_rsn(ie, 2 + ie[1], &data) == 0 &&
 	    (data.key_mgmt & WPA_KEY_MGMT_OSEN))
@@ -1205,8 +1205,10 @@
 	osen = ie != NULL;
 
 #ifdef CONFIG_SAE
-	ie = wpa_bss_get_ie(bss, WLAN_EID_RSNX);
-	if (ie && ie[1] >= 1)
+	ie = wpa_bss_get_rsnxe(bss);
+	if (ie && ie[0] == WLAN_EID_VENDOR_SPECIFIC && ie[1] >= 4 + 1)
+		rsnxe_capa = ie[4 + 2];
+	else if (ie && ie[1] >= 1)
 		rsnxe_capa = ie[2];
 #endif /* CONFIG_SAE */
 
@@ -1535,7 +1537,7 @@
 	ie = wpa_bss_get_vendor_ie(bss, WPA_IE_VENDOR_TYPE);
 	wpa_ie_len = ie ? ie[1] : 0;
 
-	ie = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	ie = wpa_bss_get_rsne(bss);
 	rsn_ie_len = ie ? ie[1] : 0;
 
 	ie = wpa_bss_get_vendor_ie(bss, OSEN_IE_VENDOR_TYPE);
@@ -1878,7 +1880,7 @@
 		if (ssid == NULL)
 			continue;
 
-		rsn = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+		rsn = wpa_bss_get_rsne(bss);
 		if (rsn == NULL)
 			continue;
 
@@ -2834,7 +2836,7 @@
 	if (wpa_s->wpa_proto & (WPA_PROTO_RSN | WPA_PROTO_OSEN)) {
 		const u8 *bss_rsn;
 
-		bss_rsn = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+		bss_rsn = wpa_bss_get_rsne(bss);
 		if (bss_rsn) {
 			p = bss_rsn;
 			len = 2 + bss_rsn[1];
@@ -3200,9 +3202,19 @@
 			wpa_sm_set_ap_rsn_ie(wpa_s->wpa, p, len);
 		}
 
+		if (p[0] == WLAN_EID_VENDOR_SPECIFIC && p[1] >= 6 &&
+		    WPA_GET_BE32(&p[2]) == RSNE_OVERRIDE_IE_VENDOR_TYPE) {
+			rsn_found = 1;
+			wpa_sm_set_ap_rsn_ie(wpa_s->wpa, p, len);
+		}
+
 		if (p[0] == WLAN_EID_RSNX && p[1] >= 1)
 			wpa_sm_set_ap_rsnxe(wpa_s->wpa, p, len);
 
+		if (p[0] == WLAN_EID_VENDOR_SPECIFIC && p[1] >= 6 &&
+		    WPA_GET_BE32(&p[2]) == RSNXE_OVERRIDE_IE_VENDOR_TYPE)
+			wpa_sm_set_ap_rsnxe(wpa_s->wpa, p, len);
+
 		l -= len;
 		p += len;
 	}
@@ -3260,8 +3272,8 @@
 
 	bss_wpa = wpa_bss_get_vendor_ie(wpa_s->current_bss,
 					WPA_IE_VENDOR_TYPE);
-	bss_rsn = wpa_bss_get_ie(wpa_s->current_bss, WLAN_EID_RSN);
-	bss_rsnx = wpa_bss_get_ie(wpa_s->current_bss, WLAN_EID_RSNX);
+	bss_rsn = wpa_bss_get_rsne(wpa_s->current_bss);
+	bss_rsnx = wpa_bss_get_rsnxe(wpa_s->current_bss);
 
 	if (wpa_sm_set_ap_wpa_ie(wpa_s->wpa, bss_wpa,
 				 bss_wpa ? 2 + bss_wpa[1] : 0) ||
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/hs20_supplicant.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/hs20_supplicant.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/hs20_supplicant.c	2024-11-20 12:19:55.801803000 +0800
@@ -1088,7 +1088,7 @@
 		prov_anqp = bss->anqp->hs20_osu_providers_list;
 		if (prov_anqp == NULL)
 			continue;
-		ie = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+		ie = wpa_bss_get_rsne(bss);
 		if (ie && wpa_parse_wpa_ie(ie, 2 + ie[1], &data) == 0 &&
 		    (data.key_mgmt & WPA_KEY_MGMT_OSEN)) {
 			osu_ssid2 = bss->ssid;
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/interworking.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/interworking.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/interworking.c	2024-11-20 12:19:55.833815000 +0800
@@ -1705,7 +1705,7 @@
 		   " for connection",
 		   MAC2STR(bss->bssid));
 
-	if (!wpa_bss_get_ie(bss, WLAN_EID_RSN)) {
+	if (!wpa_bss_get_rsne(bss)) {
 		/*
 		 * We currently support only HS 2.0 networks and those are
 		 * required to use WPA2-Enterprise.
@@ -2438,7 +2438,7 @@
 		cred2 = interworking_credentials_available(wpa_s, bss, NULL);
 		if (!cred2)
 			continue;
-		if (!wpa_bss_get_ie(bss, WLAN_EID_RSN))
+		if (!wpa_bss_get_rsne(bss))
 			continue;
 		prio = roaming_prio(wpa_s, cred2, bss);
 		wpa_printf(MSG_DEBUG, "Interworking: roaming_prio=%u for BSS "
@@ -2490,7 +2490,7 @@
 		if (!cred)
 			continue;
 
-		if (!wpa_bss_get_ie(bss, WLAN_EID_RSN)) {
+		if (!wpa_bss_get_rsne(bss)) {
 			/*
 			 * We currently support only HS 2.0 networks and those
 			 * are required to use WPA2-Enterprise.
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/mbo.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/mbo.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/mbo.c	2024-11-20 12:19:55.841828000 +0800
@@ -115,7 +115,7 @@
 		return;
 	if (oce && oce[1] >= 1 && (oce[2] & OCE_IS_STA_CFON))
 		return; /* STA-CFON is not required to enable PMF */
-	rsne = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	rsne = wpa_bss_get_rsne(bss);
 	if (!rsne || wpa_parse_wpa_ie(rsne, 2 + rsne[1], &ie) < 0)
 		return; /* AP is not using RSN */
 
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/pasn_supplicant.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/pasn_supplicant.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/pasn_supplicant.c	2024-11-20 12:19:55.862855000 +0800
@@ -1143,7 +1143,7 @@
 		return NULL;
 	}
 
-	rsne = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	rsne = wpa_bss_get_rsne(bss);
 	if (!rsne) {
 		wpa_printf(MSG_DEBUG, "PASN: BSS without RSNE");
 		return NULL;
@@ -1199,13 +1199,13 @@
 		goto fail;
 	}
 
-	rsne = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	rsne = wpa_bss_get_rsne(bss);
 	if (!rsne) {
 		wpa_printf(MSG_DEBUG, "PASN: BSS without RSNE");
 		goto fail;
 	}
 
-	rsnxe = wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+	rsnxe = wpa_bss_get_rsnxe(bss);
 
 	ret = wpas_pasn_start(wpa_s, awork->bssid, awork->akmp, awork->cipher,
 			      awork->group, bss->freq, rsne, *(rsne + 1) + 2,
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/sme.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/sme.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/sme.c	2024-11-20 12:19:55.899868000 +0800
@@ -155,8 +155,11 @@
 	if (bss) {
 		const u8 *rsnxe;
 
-		rsnxe = wpa_bss_get_ie(bss, WLAN_EID_RSNX);
-		if (rsnxe && rsnxe[1] >= 1)
+		rsnxe = wpa_bss_get_rsnxe(bss);
+		if (rsnxe && rsnxe[0] == WLAN_EID_VENDOR_SPECIFIC &&
+		    rsnxe[1] >= 1 + 4)
+			rsnxe_capa = rsnxe[2 + 4];
+		else if (rsnxe && rsnxe[1] >= 1)
 			rsnxe_capa = rsnxe[2];
 	}
 #ifdef CONFIG_MTK_IEEE80211BE
@@ -481,7 +484,7 @@
 		const u8 *rsn;
 		struct wpa_ie_data ied;
 
-		rsn = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+		rsn = wpa_bss_get_rsne(bss);
 		if (!rsn) {
 			wpa_dbg(wpa_s, MSG_DEBUG,
 				"SAE enabled, but target BSS does not advertise RSN");
@@ -516,7 +519,7 @@
 #endif /* CONFIG_WEP */
 
 	if ((wpa_bss_get_vendor_ie(bss, WPA_IE_VENDOR_TYPE) ||
-	     wpa_bss_get_ie(bss, WLAN_EID_RSN)) &&
+	     wpa_bss_get_rsne(bss)) &&
 	    wpa_key_mgmt_wpa(ssid->key_mgmt)) {
 		int try_opportunistic;
 		const u8 *cache_id = NULL;
@@ -635,7 +638,7 @@
 		wpa_dbg(wpa_s, MSG_DEBUG, "SME: FT mobility domain %02x%02x",
 			md[0], md[1]);
 
-		omit_rsnxe = !wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+		omit_rsnxe = !wpa_bss_get_rsnxe(bss);
 		if (wpa_s->sme.assoc_req_ie_len + 5 <
 		    sizeof(wpa_s->sme.assoc_req_ie)) {
 			struct rsn_mdie *mdie;
@@ -664,7 +667,7 @@
 
 	wpa_s->sme.mfp = wpas_get_ssid_pmf(wpa_s, ssid);
 	if (wpa_s->sme.mfp != NO_MGMT_FRAME_PROTECTION) {
-		const u8 *rsn = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+		const u8 *rsn = wpa_bss_get_rsne(bss);
 		struct wpa_ie_data _ie;
 		if (rsn && wpa_parse_wpa_ie(rsn, 2 + rsn[1], &_ie) == 0 &&
 		    _ie.capabilities &
@@ -2080,6 +2083,31 @@
 		}
 		wpa_s->sme.assoc_req_ie_len += multi_ap_ie_len;
 	}
+#ifdef CONFIG_TESTING_OPTIONS
+	{
+		extern bool wpas_disable_rsn_override;
+
+		if (wpas_disable_rsn_override)
+			goto skip_rsne_override;
+	}
+#endif /* CONFIG_TESTING_OPTIONS */
+	if (wpa_s->current_bss &&
+	    wpa_bss_get_vendor_ie(wpa_s->current_bss,
+				  RSNE_OVERRIDE_IE_VENDOR_TYPE) &&
+	    wpa_s->sme.assoc_req_ie_len + 2 + 4 <=
+	    sizeof(wpa_s->sme.assoc_req_ie)) {
+		u8 *pos = wpa_s->sme.assoc_req_ie + wpa_s->sme.assoc_req_ie_len;
+
+		/* Indicate support for RSN overriding */
+		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+		*pos++ = 4;
+		WPA_PUT_BE32(pos, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+		wpa_s->sme.assoc_req_ie_len += 2 + 4;
+	}
+
+#ifdef CONFIG_TESTING_OPTIONS
+skip_rsne_override:
+#endif /* CONFIG_TESTING_OPTIONS */
 
 	params.bssid = bssid;
 	params.ssid = wpa_s->sme.ssid;
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/wpa_supplicant.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/wpa_supplicant.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/wpa_supplicant.c	2024-11-20 12:19:55.926885000 +0800
@@ -1415,8 +1415,8 @@
 
 	if (bss) {
 		bss_wpa = wpa_bss_get_vendor_ie(bss, WPA_IE_VENDOR_TYPE);
-		bss_rsn = wpa_bss_get_ie(bss, WLAN_EID_RSN);
-		bss_rsnx = wpa_bss_get_ie(bss, WLAN_EID_RSNX);
+		bss_rsn = wpa_bss_get_rsne(bss);
+		bss_rsnx = wpa_bss_get_rsnxe(bss);
 		bss_osen = wpa_bss_get_vendor_ie(bss, OSEN_IE_VENDOR_TYPE);
 	} else {
 		bss_wpa = bss_rsn = bss_rsnx = bss_osen = NULL;
@@ -3055,7 +3055,7 @@
 	}
 
 	if (bss && (wpa_bss_get_vendor_ie(bss, WPA_IE_VENDOR_TYPE) ||
-		    wpa_bss_get_ie(bss, WLAN_EID_RSN)) &&
+		    wpa_bss_get_rsne(bss)) &&
 	    wpa_key_mgmt_wpa(ssid->key_mgmt)) {
 		int try_opportunistic;
 		const u8 *cache_id = NULL;
@@ -3512,6 +3512,19 @@
 		wpa_ie_len += multi_ap_ie_len;
 	}
 
+	if (bss && wpa_bss_get_vendor_ie(bss, RSNE_OVERRIDE_IE_VENDOR_TYPE) &&
+	    wpa_ie_len + 2 + 4 <= max_wpa_ie_len) {
+		u8 *pos = wpa_ie + wpa_ie_len;
+
+		/* Indicate support for RSN overriding */
+		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
+		*pos++ = 4;
+		WPA_PUT_BE32(pos, RSNE_OVERRIDE_IE_VENDOR_TYPE);
+		pos += 4;
+		wpa_hexdump(MSG_MSGDUMP, "RSNE Override", wpa_ie, pos - wpa_ie);
+		wpa_ie_len += 2 + 4;
+	}
+
 	params->wpa_ie = wpa_ie;
 	params->wpa_ie_len = wpa_ie_len;
 	params->auth_alg = algs;
@@ -4044,7 +4057,7 @@
 
 	params.mgmt_frame_protection = wpas_get_ssid_pmf(wpa_s, ssid);
 	if (params.mgmt_frame_protection != NO_MGMT_FRAME_PROTECTION && bss) {
-		const u8 *rsn = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+		const u8 *rsn = wpa_bss_get_rsne(bss);
 		struct wpa_ie_data ie;
 		if (rsn && wpa_parse_wpa_ie(rsn, 2 + rsn[1], &ie) == 0 &&
 		    ie.capabilities &
Index: hostapd-2022-07-29-b704dc72/wpa_supplicant/wps_supplicant.c
===================================================================
--- hostapd-2022-07-29-b704dc72.orig/wpa_supplicant/wps_supplicant.c	2024-11-20 12:19:55.950810000 +0800
+++ hostapd-2022-07-29-b704dc72/wpa_supplicant/wps_supplicant.c	2024-11-20 12:19:55.939946000 +0800
@@ -216,7 +216,7 @@
 
 	wpa_printf(MSG_DEBUG, "WPS: AP found from BSS table");
 
-	ie = wpa_bss_get_ie(bss, WLAN_EID_RSN);
+	ie = wpa_bss_get_rsne(bss);
 	if (ie && wpa_parse_wpa_ie(ie, 2 + ie[1], &adv) == 0) {
 		wpa2 = 1;
 		if (adv.pairwise_cipher & WPA_CIPHER_CCMP)
